---
title: 网络通不通是个大问题–半夜鸡叫
date: 2019-05-16 17:30:03
categories:
    - network
tags:
    - TCP
    - performance
    - rp_filter
    - network
    - route
    - iptables
    - tcpdump

---

# 网络通不通是个大问题--半夜鸡叫

## 半夜鸡叫


凌晨啊，还有同学在为网络为什么不通的问题奋斗着：

![undefined](https://plantegg.oss-cn-beijing.aliyuncs.com/images/oss/1557909424085-04a7111c-fee8-440f-ba22-411dd70cbba0.png) 


问题描述大概如下：

slb后面配了一台realserver(就叫172吧), 在172上通过curl http://127.0.0.1:80/ 是正常的(说明服务自身是正常的)
如果从开发同学的笔记本直接curl slb-ip 就卡住了，进一步发现如果从北京的办公网curl slb-ip就行，但是从杭州的curl slb-ip就不行。

从杭州curl的时候在172上抓包如下：
![undefined](https://plantegg.oss-cn-beijing.aliyuncs.com/images/oss/1557909749498-452acc94-f04b-48bf-803f-f1acb21dd4b2.png) 

明显可以看到tcp握手包正确到达了172，但是172一直没有回复。也就是如果是杭州访问服务的话，服务端收到握手请求后直接扔掉没有任何回复（回想下哪些场景会扔包）

## 问题排查

### 先排除了iptables的问题

	略过

### route 的嫌疑

因为北京可以杭州不行，明显是某些IP可以，于是检查route 表，解决问题的[必杀技(基础知识)都在这里](https://www.atatech.org/articles/80573)
	
发现杭州的ip和北京的ip确实命中了不同的路由规则，简单说就是172绑在eth0上，机器还有另外一块网卡eth1. 而回复杭州ip的时候要走eth1. 至于为什么没有从eth1回复等会再说
	
知道原因就好说了，修改一下route，让eth0成为默认路由，这样北京、杭州都能走eth0进出了
	
所以到这里，问题描述如下：
	![undefined](https://plantegg.oss-cn-beijing.aliyuncs.com/images/oss/1557910281403-59a60a80-5edf-472d-827c-b2c8d6db903f.png) 
	
机器有两块网卡，请求走eth0 进来(绿线)，然后走 eth1回复(路由决定的，红线)，但是实际没走eth1回复，像是丢包了。
	
### 解决办法

修改一下route，让eth0成为默认路由，这样北京、杭州都能走eth0进出了
	
### 为什么5U的机器可以

开发同学接着反馈，出问题的172是7U2的系统，但是还有一些5U7的机器完全正常，5U7的机器上也是两块网卡，route规则也是一样的。
	
这确实诡异，看着像是7U的内核行为跟5U不一致，咨询了内核同学，让检查一下 rp_filter 参数。果然看到7U2的系统默认 rp_filter 开着，而5U7是关着的，于是反复开关这个参数稳定重现了问题	

```
sysctl -w net.ipv4.conf.eth0.rp_filter=0 
```

### rp_filter 原理

rp_filter参数用于控制系统是否开启对数据包源地址的校验, 收到包后根据source ip到route表中检查是否否和最佳路由，否的话扔掉这个包【可以防止DDoS，攻击等】

> ​    0：不开启源地址校验。
> ​	1：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。
> ​	2：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不通，则直接丢弃该数据包。

那么对于这种丢包，可以打开日志：/proc/sys/net/ipv4/conf/eth0/log_martians 来监控到：

![undefined](https://plantegg.oss-cn-beijing.aliyuncs.com/images/oss/1557910737844-1ee231f0-1ddd-4dee-ac07-3b23f9659878.png) 

## 总结

本质原因就是服务器开启了 rp_filter 为1，严格校验进出包是否走同一块网卡，而如果请求从杭州机房发过来的话，回复包的路由走的是另外一块网卡，触发了内核的rp_filter扔包逻辑。

改server的路由可以让杭州的包也走同一块网卡，就不扔掉了。当然将 rp_filter 改成0 关掉这个校验逻辑也可以完全避免这个扔包。

从问题的解决思路来说，基本都可以认定是握手的时候服务器扔包了。只有知道 rp_filter 参数的内核老司机可以直接得出是这里的原因。如果对于一个新手的话还是得掌握如何推理分析得到原因。
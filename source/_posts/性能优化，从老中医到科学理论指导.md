---
title:  性能优化，从老中医到科学理论指导
date: 2018-08-24 16:30:03
categories: performance
tags:
    - Linux
    - performance
    - troubleshooting
    - network
---

# 性能优化，从老中医到科学理论指导

简单原理：

- 追着RT去优化，哪个环节、节点RT高，哪里就值得优化，CPU、GC等等只是导致RT高的因素，RT才是结果；

- QPS=并发/RT

  

## 利特尔法则[[编辑](https://zh.wikipedia.org/w/index.php?title=利特爾法則&action=edit&section=0&summary=/* top */ )]

**利特尔法则**（英语：Little's law），基于[等候理论](https://zh.wikipedia.org/wiki/等候理論)，由[约翰·利特尔](https://zh.wikipedia.org/w/index.php?title=約翰·利特爾&action=edit&redlink=1)在1954年提出。利特尔法则可用于一个稳定的、非占先式的系统中。其内容为：

> 在一个稳定的系统中，长期的平均顾客人数（L），等于长期的有效抵达率（λ），乘以顾客在这个系统中平均的等待时间（W）

或者，我们可以用一个代数式来表达：

L=λW

利特尔法则可用来确定在途存货的数量。此法则认为，系统中的平均存货等于存货单位离开系统的比率（亦即平均需求率）与存货单位在系统中平均时间的乘积。

虽然此公式看起来直觉性的合理，它依然是个非常杰出的推导结果，因为此一关系式“不受到货流程分配、服务分配、服务顺序，或任何其他因素影响”。

此一理论适用于所有系统，而且它甚至更适合用于系统中的系统。举例来说，在一间银行里，顾客等待的队伍就是一个子系统，而每一位柜员也可以被视为一个等待的子系统，而利特尔法则可以套用到任何一个子系统，也可以套用到整个银行的等待队伍之母系统。

唯一的条件就是，这个系统必须是长期稳定的，而且不能有插队抢先的情况发生，这样才能排除换场状况的可能性，例如开业或是关厂。

### 案例：

需要的线程数 = qps * latency(单位秒)。 依据是little's law，类似的应用是tcp中的bandwidth-delay product。如果这个数目远大于核心数量，应该考虑用异步接口。
举例：

- qps = 2000，latency = 10ms，计算结果 = 2000 * 0.01s = 20。和常见核数在同一个数量级，用同步。
- qps = 100, latency = 5s, 计算结果 = 100 * 5s = 500。和常见核数不在同一个数量级，用异步。
- qps = 500, latency = 100ms，计算结果 = 500 * 0.1s = 50。和常见核数在同一个数量级，可用同步。如果未来延时继续增长，考虑异步。

![image-20211103175727900](https://plantegg.oss-cn-beijing.aliyuncs.com/images/951413iMgBlog/image-20211103175727900.png)

## 理解最佳线程数量

最佳线程数量

单线程压测，总rt(total)，下游依赖rt(IO), rt(CPU)=rt(total)-rt(IO)

最佳线程数量 rt(total)/rt(cpu)

维持住rt

这一点占性能优化领域的50%

从单线程跑出QPS、各个环节的RT、CPU占用等数据

然后加并发直到QPS不再增加，然后看哪个环境RT增加最大，瓶颈就在哪里

## 思路严谨

最难讲清楚

## 老中医经验不可缺少

量变到质变

## 找瓶颈，先干掉瓶颈才能优化其它

没有找到瓶颈，所做的其它优化会看不出效果，误入歧途，瞎蒙

## 全栈能力，一文钱难倒英雄好汉

因为关键是找瓶颈，作为java程序员如果只能看jstack、jstat可能发现的不是瓶颈

## 案列

https://www.atatech.org/articles/73174

